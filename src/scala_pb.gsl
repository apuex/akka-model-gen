.template 1
.pkgdir = "message/src/main/protobuf/$(string.replace(entities.package, ".|/"))"
.directory.create(pkgdir)
.output "$(pkgdir)/messages.proto"
/*************************************************** 
 * This file is 100% ***GENERATED***, DO NOT EDIT! *
 ***************************************************/
syntax = "proto2";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";

import "scalapb/scalapb.proto";
option (scalapb.options) = {
  flat_package: true
};

package $(entities.package).message;


.for entity
message $(entity.name:Pascal)Vo {
  option (scalapb.message).extends = "$(entities.package).ValueObject";
.fieldNo = 1
.for field
.  if defined(field.transient) & field.transient = "true"
.  else
  $(pb_output_field(field, fieldNo))
.    fieldNo = fieldNo + 1
.  endif
.endfor  
};

.aggRoot = ""
.if defined(entity.aggregationRoot) & entity.aggregationRoot = "true"
.  pk = pb_extract_pk(entity)
.  aggRoot = entity.name
message Retrieve$(entity.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.  fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
};

.  for field
.    theField = field
.    if field.type = "array" | field.type = "map"
message Add$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
  $(pb_output_field(field, fieldNo))
};

message Remove$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
  $(pb_output_field(field, fieldNo))
};

.     elsif !defined(pk->field(name = theField.name))
message Modify$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
  $(pb_output_field(field, fieldNo))
};

.    else
.    endif    
.  endfor
.elsif defined(entity.aggregationTo)
.  aggRoot = "$(entity.aggregationTo)"
.else
.  abort "E: no aggregationRoot or aggregationTo is defined on entity $(entity.name)." 
.endif
message Create$(entity.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationTo)
.  keys = pb_output_fk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  if defined(field.transient) & field.transient = "true"
.  else
  $(pb_output_field(field, fieldNo))
.    fieldNo = fieldNo + 1
.  endif
.endfor  
};

.for aggregation
message Update$(aggregation.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationRoot)
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  theField = field
.  af = entity->field(name = theField.name)
  $(pb_output_field(af, fieldNo))
. fieldNo = fieldNo + 1
.endfor  
};

message Get$(aggregation.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(entities.package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationRoot)
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
};

.endfor
.endfor
.endtemplate
