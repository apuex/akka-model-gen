.template 1
.pkgdir = "message/src/main/protobuf/$(string.replace(model.package, ".|/"))"
.directory.create(pkgdir)
.output "$(pkgdir)/messages.proto"
/*************************************************** 
 * This file is 100% ***GENERATED***, DO NOT EDIT! *
 ***************************************************/
syntax = "proto2";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";

import "scalapb/scalapb.proto";
option (scalapb.options) = {
  flat_package: true
};
.package = "$(model.package).message"
package $(package);


.for entity
message $(entity.name:Pascal)Vo {
  option (scalapb.message).extends = "$(package).ValueObject";
.fieldNo = 1
.for field
.  if defined(field.transient) & field.transient = "true"
.  else
  $(pb_output_field(field, fieldNo))
.    fieldNo = fieldNo + 1
.  endif
.endfor  
};

.aggRoot = ""
.if defined(entity.aggregationRoot) & entity.aggregationRoot = "true"
.  pk = pb_extract_pk(entity)
.  aggRoot = entity.name
.
message Create$(entity.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationTo)
.  keys = pb_output_fk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  if defined(field.transient) & field.transient = "true"
.  else
  $(pb_output_field(field, fieldNo))
.    fieldNo = fieldNo + 1
.  endif
.endfor
};

message Create$(entity.name:Pascal)Evt {
  option (scalapb.message).extends = "$(package).Event";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationTo)
.  keys = pb_output_fk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  if defined(field.transient) & field.transient = "true"
.  else
  $(pb_output_field(field, fieldNo))
.    fieldNo = fieldNo + 1
.  endif
.endfor
};

message Retrieve$(entity.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.  fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
};

.  for field
.    theField = field
.    if field.type = "array" | field.type = "map"
message Add$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

message Add$(field.name:Pascal)Evt {
  option (scalapb.message).extends = "$(package).Event";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

message Remove$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

message Remove$(field.name:Pascal)Evt {
  option (scalapb.message).extends = "$(package).Event";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

.     elsif !defined(pk->field(name = theField.name)) & !(defined(field.transient) & field.transient="true")
message Change$(field.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

message Change$(field.name:Pascal)Evt {
  option (scalapb.message).extends = "$(package).Event";
  optional string userId = 1;
.      fieldNo = 2
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
  $(pb_output_field(field, fieldNo))
};

.    else
.    endif    
.  endfor
.elsif defined(entity.aggregationTo)
.  aggRoot = "$(entity.aggregationTo)"
.else
.  ###abort "E: no aggregationRoot or aggregationTo is defined on entity $(entity.name)."
.endif
.
.for aggregation
message Update$(aggregation.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationRoot)
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  theField = field
.  if defined(field.type)
  $(pb_output_field(field, fieldNo))
.  else
.    af = entity->field(name = theField.name)
  $(pb_output_field(af, fieldNo))
.  endif
. fieldNo = fieldNo + 1
.endfor  
};

message $(aggregation.name:Pascal)Vo{
  option (scalapb.message).extends = "$(package).ValueObject";
.fieldNo = 1
.if defined(entity.aggregationRoot)
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
.for field
.  theField = field
.  if defined(field.type)
  $(pb_output_field(field, fieldNo))
.  else
.    af = entity->field(name = theField.name)
  $(pb_output_field(af, fieldNo))
.  endif
. fieldNo = fieldNo + 1
.endfor
};

message Get$(aggregation.name:Pascal)Cmd {
  option (scalapb.message).extends = "$(package).$(aggRoot:Pascal)Command";
  optional string userId = 1;
.fieldNo = 2
.if defined(entity.aggregationRoot)
.  keys = pb_output_pk(entity, fieldNo)
.  if string.length(keys) > 0
  $(keys:no)
.  endif
.endif
};

.endfor
.endfor
.endtemplate
